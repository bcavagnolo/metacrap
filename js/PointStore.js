/**
 * Create a Point suitable to be stored in the PointStore
 * @param {Array} array containing lat and lon as floats
 * @param {string} name of the point (e.g., "Vital Vittles")
 * @param {string} the type of the point (e.g., restaurant)
 * @param {Array} array of tags
 */
function Point(posn, name, type, tags) {
  this.posn = posn;
  this.name = name;
  this.type = type;
  this.tags = tags;

  /* the following members are used internally by PointStore and should not be
   * altered by the caller
   */
  this.idx = -1;
}

/**
 * Create a PointStore to store a bunch of geo points and their attributes
 *
 * Uses <a href="http://http://openkeyval.org/">open key value service.</a> to
 * persist a list of points.  Each JSON point is serialized and stored at its
 * own key.  The key name is generated by appending a number n to the name
 * space to form nameSpace_n.  All values with keys of the form nameSpace_n are
 * loaded until a 404 is returned.
 *
 * Internally, the list of points is stored as a List.js list so that we can
 * ultimately use its fuzzy searching capability to battle metacrap.
 *
 * @param {Object} key-value pairs specifying the following options:
 * <ul>
 * <li>openKVURL: url of openkv server to use as back end</li>
 * <li>nameSpace: [hopefully] unique nameSpace for use on openKV</li>
 * <li>listID: the html element id where list items can be persisted</li>
 * <li>createPointDisplay: callback that creates the display for a point</li> 
 * <li>showPoint: callback that shows a point</li>
 * <li>hidePoint: callback that hides a point</li>
 * </ul>
 *
 * NOTE: This storage scheme suffers from ample problems that a conventional DB
 * resolves including concurrency issues between clients, no support for unique
 * base names, terrible search algorithms, etc.
 *
 * NOTE: For our purposes, we want to leave the gory html details up to the
 * user.  But gutting list.js to eliminate the listID proved to be too
 * ambitious for this project.  So we require it.
 */
function PointStore(options) {

  /* It took me a while to figure this out because list.js "templates" do not
   * seem to be documented. So let me explain it in a bit of detail.  This
   * class is responsible for showing and hiding elements as the search terms
   * change.  The html elements are consistently referred to as "items" and the
   * data that is used to populate the "item" is referred to as a "value".
   * "items" must be "created" before they get populated.  For our purposes, we
   * just want the user to pass us functions to create, show, and hide items.
   * That is, we don't want to mess with any html, we let them do that.  So in
   * this template implementation, we don't care about the "items", we only
   * care about the "values".
   */
  List.prototype.templateEngines.external = function(list, settings) {

    this.set = function(item, values) {
      if (options.createPointDisplay)
        options.createPointDisplay(values);
    };

    this.show = function(item) {
      if (options.showPoint)
        options.showPoint(item.values());
    };

    this.hide = function(item) {
      if (options.hidePoint)
        options.hidePoint(item.values());
    };

    this.clear = function() {
    };

    this.remove = function(item) {
    };
  };

  this.listOptions = {
    /* this is the hard-coded list of members of the Point structure to be
     * used in the fuzzy matching.
     */
    valueNames: [ 'name', 'type', 'tags' ],
    engine:"external",
    plugins: [
      [ 'fuzzySearch' ]
    ],
  };
  var points = new List(options.listID, this.listOptions);
  this.points = points;
  if (options.searchBoxID) {
    console.log("the entire list");
    console.log($('#'+ options.searchBoxID));
    $('#'+ options.searchBoxID).keyup(function() {
         //console.log(options.searchBoxID);
      points.fuzzySearch($(this).val());
    });
  }
  this.options = options;
  this.end = 0;
  this.deleting = 0;
}

PointStore.prototype._getURL = function(i, store) {
  if (store)
    return this.options.openKVURL + 'store/';
  else
    return this.options.openKVURL + this.options.nameSpace + "_" + i;
}

/**
 * load points from persistent storage
 * @param {function} function to be called after initial loading is complete
 */
PointStore.prototype.load = function(success) {
  ps = this;
  $.ajax({
    ps: ps,
    psSuccess: success,
    url: this._getURL(this.end),
    dataType: "jsonp",
    success: function(data) {
      if (!data) {
        /* in this case, we're done */
        if (this.psSuccess) {
          this.psSuccess();
        }
        return;
      }
      if (data != "deleted") {
        this.ps.points.add(JSON.parse(data));
      }
      this.ps.end++;
      /* Recursion.  Bold.  Hopefully we won't run out of stack. */
      this.ps.load(this.psSuccess);
    }
  });
};

/**
 * get all points with a certain tag in the top-level tag member.
 *
 * @return (possibly empty) list of points
 */
PointStore.prototype.getByTag = function(tag) {
  return this.points.values().filter(function(p) {
    return ($.inArray(tag, p.tags) != -1);
  });
};

/**
 * get all points of a certain type.
 *
 * @return (possibly empty) list of points
 */
PointStore.prototype.getByType = function(type) {
  return this.points.values().filter(function(p) {
    return (p.type == type);
  });
};

/**
 * get complete list of points
 *
 * @return (possibly empty) list of points
 */
PointStore.prototype.getAll = function() {
  return this.points.values();
};

/**
 * @return number of points contained in the PointStore
 */
PointStore.prototype.length = function() {
  return this.points.values().length;
};

/**
 * update a point in the PointStore
 *
 * If the point does not exist in the PointStore, it will be created.
 * @param {Point} the point to update
 * @param {function} to call after the save succeeds (optional)
 *
 * @note that only the known members of the Point class will be stored.  Any
 * members added by the user will be dropped.
 */
PointStore.prototype.updatePoint = function(p, success) {
  if (p.idx == -1) {
    p.idx = this.end++;
  } else {
    this.points.remove('idx', p.idx);
  }
  var pRef = new Point();
  var keys = Object.keys(pRef);
  for (var i=0; i<keys.length; i++) {
    pRef[keys[i]] = p[keys[i]];
  }
  var ps = this;
  var data = new Object();
  data[this.options.nameSpace + "_" + p.idx] = JSON.stringify(pRef);
  $.ajax({
    ps: ps,
    psSuccess: success,
    url: this._getURL(p.idx, true),
    data: data,
    dataType: "jsonp",
    success: function(data) {
      this.ps.points.add(pRef);
      if (this.psSuccess) {
        this.psSuccess();
      }
    }
  });
};

/**
 * remove a point from the PointStore
 * @param {Point} the point p to remove
 * @param {function} to be called after deleting is complete
 *
 * @note: we only soft delete the items.  This ends up leaving holes in the
 * list.  Yuck.
 */
PointStore.prototype.removePoint = function(p, done) {
  data = new Object();
  data[this.options.nameSpace + "_" + p.idx] = "deleted";
  ps = this;
  $.ajax({
    ps: ps,
    p: p,
    psDone: done,
    url: this._getURL(p.idx, true),
    data: data,
    dataType: "jsonp",
    success: function(data) {
      this.ps.points.remove('idx', this.p.idx);
      if (this.psDone)
        this.psDone();
    }
  });
};

/**
 * delete the entire PointStore from openkeyval
 * @param {function} to be called after deleting is complete
 */
PointStore.prototype.deletePointStore = function(done) {

  data = new Object();
  data[this.options.nameSpace + "_" + this.deleting++] = null;
  ps = this;
  $.ajax({
    ps: ps,
    psDone: done,
    url: this._getURL(this.end, true),
    data: data,
    dataType: "jsonp",
    success: function(data) {
      if (data.status == "did_not_exist") {
        this.ps.end = 0;
        this.ps.deleting = 0;
        this.ps.points = new List(this.ps.options.listID, this.ps.listOptions);
        if (this.psDone) {
          this.psDone();
        }
        return;
      }
      this.ps.deletePointStore(this.psDone);
    },
  });
};
